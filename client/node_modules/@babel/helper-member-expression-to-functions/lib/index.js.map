<<<<<<< HEAD
{"version":3,"file":"index.js","sources":["../src/util.ts","../src/index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\n\n/**\n * Test if a NodePath will be cast to boolean when evaluated.\n *\n * @example\n * // returns true\n * const nodePathAQDotB = NodePath(\"if (a?.#b) {}\").get(\"test\"); // a?.#b\n * willPathCastToBoolean(nodePathAQDotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a?.#b\"))\n * @todo Respect transparent expression wrappers\n * @see {@link packages/babel-plugin-proposal-optional-chaining/src/util.js}\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = path;\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n","import type { NodePath, Visitor } from \"@babel/traverse\";\nimport {\n  LOGICAL_OPERATORS,\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  identifier,\n  isMemberExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isUpdateExpression,\n  logicalExpression,\n  memberExpression,\n  nullLiteral,\n  optionalCallExpression,\n  optionalMemberExpression,\n  sequenceExpression,\n  updateExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { willPathCastToBoolean } from \"./util\";\n\nclass AssignmentMemoiser {\n  private _map: WeakMap<t.Expression, { count: number; value: t.Identifier }>;\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key: t.Expression) {\n    return this._map.has(key);\n  }\n\n  get(key: t.Expression) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n    const { value } = record;\n\n    record.count--;\n    if (record.count === 0) {\n      // The `count` access is the outermost function call (hopefully), so it\n      // does the assignment.\n      return assignmentExpression(\"=\", value, key);\n    }\n    return value;\n  }\n\n  set(key: t.Expression, value: t.Identifier, count: number) {\n    return this._map.set(key, { count, value });\n  }\n}\n\nfunction toNonOptional(\n  path: NodePath<t.Expression>,\n  base: t.Expression,\n): t.Expression {\n  const { node } = path;\n  if (isOptionalMemberExpression(node)) {\n    return memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      // object must be a conditional expression because the optional private access in object has been transformed\n      const object = callee.node.object as t.ConditionalExpression;\n      const context = path.scope.maybeGenerateMemoised(object);\n      callee\n        .get(\"object\")\n        .replaceWith(assignmentExpression(\"=\", context, object));\n\n      return callExpression(memberExpression(base, identifier(\"call\")), [\n        context,\n        ...path.node.arguments,\n      ]);\n    }\n\n    return callExpression(base, path.node.arguments);\n  }\n\n  return path.node;\n}\n\n// Determines if the current path is in a detached tree. This can happen when\n// we are iterating on a path, and replace an ancestor with a new node. Babel\n// doesn't always stop traversing the old node tree, and that can cause\n// inconsistencies.\nfunction isInDetachedTree(path: NodePath) {\n  while (path) {\n    if (path.isProgram()) break;\n\n    const { parentPath, container, listKey } = path;\n    const parentNode = parentPath.node;\n    if (listKey) {\n      if (\n        container !==\n        // @ts-expect-error listKey must be a valid parent node key\n        parentNode[listKey]\n      ) {\n        return true;\n      }\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\ntype Member = NodePath<t.OptionalMemberExpression | t.MemberExpression>;\n\nconst handle = {\n  memoise() {\n    // noop.\n  },\n\n  handle(this: HandlerState, member: Member, noDocumentAll: boolean) {\n    const { node, parent, parentPath, scope } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      // Transforming optional chaining requires we replace ancestors.\n      if (isInDetachedTree(member)) return;\n\n      // We're looking for the end of _this_ optional chain, which is actually\n      // the \"rightmost\" property access of the chain. This is because\n      // everything up to that property access is \"optional\".\n      //\n      // Let's take the case of `FOO?.BAR.baz?.qux`, with `FOO?.BAR` being our\n      // member. The \"end\" to most users would be `qux` property access.\n      // Everything up to it could be skipped if it `FOO` were nullish. But\n      // actually, we can consider the `baz` access to be the end. So we're\n      // looking for the nearest optional chain that is `optional: true`.\n      const endPath = member.find(({ node, parent }) => {\n        if (isOptionalMemberExpression(parent)) {\n          // We need to check `parent.object` since we could be inside the\n          // computed expression of a `bad?.[FOO?.BAR]`. In this case, the\n          // endPath is the `FOO?.BAR` member itself.\n          return parent.optional || parent.object !== node;\n        }\n        if (isOptionalCallExpression(parent)) {\n          // Checking `parent.callee` since we could be in the arguments, eg\n          // `bad?.(FOO?.BAR)`.\n          // Also skip `FOO?.BAR` in `FOO?.BAR?.()` since we need to transform the optional call to ensure proper this\n          return (\n            // In FOO?.#BAR?.(), endPath points the optional call expression so we skip FOO?.#BAR\n            (node !== member.node && parent.optional) || parent.callee !== node\n          );\n        }\n        return true;\n      }) as NodePath<t.OptionalMemberExpression>;\n\n      // Replace `function (a, x = a.b?.#c) {}` to `function (a, x = (() => a.b?.#c)() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unnecessary IIFE\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          callExpression(arrowFunctionExpression([], endPath.node), []),\n        );\n        return;\n      }\n\n      const willEndPathCastToBoolean = willPathCastToBoolean(endPath);\n\n      const rootParentPath = endPath.parentPath;\n      if (\n        rootParentPath.isUpdateExpression({ argument: node }) ||\n        rootParentPath.isAssignmentExpression({ left: node })\n      ) {\n        throw member.buildCodeFrameError(`can't handle assignment`);\n      }\n      const isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\",\n      });\n      if (\n        isDeleteOperation &&\n        endPath.isOptionalMemberExpression() &&\n        endPath.get(\"property\").isPrivateName()\n      ) {\n        // @babel/parser will throw error on `delete obj?.#x`.\n        // This error serves as fallback when `delete obj?.#x` is constructed from babel types\n        throw member.buildCodeFrameError(\n          `can't delete a private class element`,\n        );\n      }\n\n      // Now, we're looking for the start of this optional chain, which is\n      // optional to the left of this member.\n      //\n      // Let's take the case of `foo?.bar?.baz.QUX?.BAM`, with `QUX?.BAM` being\n      // our member. The \"start\" to most users would be `foo` object access.\n      // But actually, we can consider the `bar` access to be the start. So\n      // we're looking for the nearest optional chain that is `optional: true`,\n      // which is guaranteed to be somewhere in the object/callee tree.\n      let startingOptional: NodePath<t.Expression> = member;\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n        // prevent infinite loop: unreachable if the AST is well-formed\n        throw new Error(\n          `Internal error: unexpected ${startingOptional.node.type}`,\n        );\n      }\n\n      // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n      const startingNode = startingOptional.isOptionalMemberExpression()\n        ? // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n          startingOptional.node.object\n        : // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n          startingOptional.node.callee;\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised ?? startingNode;\n\n      // Compute parentIsOptionalCall before `startingOptional` is replaced\n      // as `node` may refer to `startingOptional.node` before replaced.\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node,\n      });\n      // here we use a function to wrap `parentIsOptionalCall` to get type\n      // for parent, do not use it anywhere else\n      // See https://github.com/microsoft/TypeScript/issues/10421\n      const isOptionalCall = (\n        parent: t.Node,\n      ): parent is t.OptionalCallExpression => parentIsOptionalCall;\n      // if parentIsCall is true, it implies that node.extra.parenthesized is always true\n      const parentIsCall = parentPath.isCallExpression({ callee: node });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n      if (isOptionalCall(parent)) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        // `(a?.#b)()` to `(a == null ? void 0 : a.#b.bind(a))()`\n        member.replaceWith(this.boundGet(member));\n      } else if (\n        this.delete &&\n        parentPath.isUnaryExpression({ operator: \"delete\" })\n      ) {\n        parentPath.replaceWith(this.delete(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular: t.Expression = member.node;\n      for (let current: NodePath = member; current !== endPath; ) {\n        const parentPath = current.parentPath as NodePath<t.Expression>;\n        // skip transforming `Foo.#BAR?.call(FOO)`\n        if (\n          parentPath === endPath &&\n          isOptionalCall(parent) &&\n          parent.optional\n        ) {\n          regular = parentPath.node;\n          break;\n        }\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context: t.Identifier;\n      const endParentPath = endPath.parentPath as NodePath<t.Expression>;\n      if (\n        isMemberExpression(regular) &&\n        endParentPath.isOptionalCallExpression({\n          callee: endPath.node,\n          optional: true,\n        })\n      ) {\n        const { object } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n        if (context) {\n          regular.object = assignmentExpression(\n            \"=\",\n            context,\n            // object must not be Super when `context` is an identifier\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n            object as t.Expression,\n          );\n        }\n      }\n\n      let replacementPath: NodePath = endPath;\n      if (isDeleteOperation) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      const baseMemoised = baseNeedsMemoised\n        ? assignmentExpression(\n            \"=\",\n            // When base needs memoised, the baseRef must be an identifier\n            cloneNode(baseRef as t.Identifier),\n            cloneNode(startingNode),\n          )\n        : cloneNode(baseRef);\n\n      if (willEndPathCastToBoolean) {\n        let nonNullishCheck;\n        if (noDocumentAll) {\n          nonNullishCheck = binaryExpression(\"!=\", baseMemoised, nullLiteral());\n        } else {\n          nonNullishCheck = logicalExpression(\n            \"&&\",\n            binaryExpression(\"!==\", baseMemoised, nullLiteral()),\n            binaryExpression(\n              \"!==\",\n              cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n        replacementPath.replaceWith(\n          logicalExpression(\"&&\", nonNullishCheck, regular),\n        );\n      } else {\n        let nullishCheck;\n        if (noDocumentAll) {\n          nullishCheck = binaryExpression(\"==\", baseMemoised, nullLiteral());\n        } else {\n          nullishCheck = logicalExpression(\n            \"||\",\n            binaryExpression(\"===\", baseMemoised, nullLiteral()),\n            binaryExpression(\n              \"===\",\n              cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n\n        replacementPath.replaceWith(\n          conditionalExpression(\n            nullishCheck,\n            isDeleteOperation\n              ? booleanLiteral(true)\n              : scope.buildUndefinedNode(),\n            regular,\n          ),\n        );\n      }\n\n      // context and isDeleteOperation can not be both truthy\n      if (context) {\n        const endParent = endParentPath.node as t.OptionalCallExpression;\n        endParentPath.replaceWith(\n          optionalCallExpression(\n            optionalMemberExpression(\n              endParent.callee,\n              identifier(\"call\"),\n              false,\n              true,\n            ),\n            [cloneNode(context), ...endParent.arguments],\n            false,\n          ),\n        );\n      }\n\n      return;\n    }\n\n    // MEMBER++   ->   _set(MEMBER, (ref = _get(MEMBER), ref2 = ref++, ref)), ref2\n    // ++MEMBER   ->   _set(MEMBER, (ref = _get(MEMBER), ++ref))\n    if (isUpdateExpression(parent, { argument: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, prefix } = parent;\n\n      // Give the state handler a chance to memoise the member, since we'll\n      // reference it twice. The second access (the set) should do the memo\n      // assignment.\n      this.memoise(member, 2);\n\n      const ref = scope.generateUidIdentifierBasedOnNode(node);\n      scope.push({ id: ref });\n\n      const seq: t.Expression[] = [\n        // ref = _get(MEMBER)\n        assignmentExpression(\"=\", cloneNode(ref), this.get(member)),\n      ];\n\n      if (prefix) {\n        seq.push(updateExpression(operator, cloneNode(ref), prefix));\n\n        // (ref = _get(MEMBER), ++ref)\n        const value = sequenceExpression(seq);\n        parentPath.replaceWith(this.set(member, value));\n\n        return;\n      } else {\n        const ref2 = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({ id: ref2 });\n\n        seq.push(\n          assignmentExpression(\n            \"=\",\n            cloneNode(ref2),\n            updateExpression(operator, cloneNode(ref), prefix),\n          ),\n          cloneNode(ref),\n        );\n\n        // (ref = _get(MEMBER), ref2 = ref++, ref)\n        const value = sequenceExpression(seq);\n        parentPath.replaceWith(\n          sequenceExpression([this.set(member, value), cloneNode(ref2)]),\n        );\n\n        return;\n      }\n    }\n\n    // MEMBER = VALUE   ->   _set(MEMBER, VALUE)\n    // MEMBER += VALUE   ->   _set(MEMBER, _get(MEMBER) + VALUE)\n    // MEMBER ??= VALUE   ->   _get(MEMBER) ?? _set(MEMBER, VALUE)\n    if (parentPath.isAssignmentExpression({ left: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, right: value } = parentPath.node;\n\n      if (operator === \"=\") {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const operatorTrunc = operator.slice(0, -1);\n        if (LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          // Give the state handler a chance to memoise the member, since we'll\n          // reference it twice. The first access (the get) should do the memo\n          // assignment.\n          this.memoise(member, 1);\n          parentPath.replaceWith(\n            logicalExpression(\n              operatorTrunc as t.LogicalExpression[\"operator\"],\n              this.get(member),\n              this.set(member, value),\n            ),\n          );\n        } else {\n          // Here, the second access (the set) is evaluated first.\n          this.memoise(member, 2);\n          parentPath.replaceWith(\n            this.set(\n              member,\n              binaryExpression(\n                operatorTrunc as t.BinaryExpression[\"operator\"],\n                this.get(member),\n                value,\n              ),\n            ),\n          );\n        }\n      }\n      return;\n    }\n\n    // MEMBER(ARGS) -> _call(MEMBER, ARGS)\n    if (parentPath.isCallExpression({ callee: node })) {\n      parentPath.replaceWith(this.call(member, parentPath.node.arguments));\n      return;\n    }\n\n    // MEMBER?.(ARGS) -> _optionalCall(MEMBER, ARGS)\n    if (parentPath.isOptionalCallExpression({ callee: node })) {\n      // Replace `function (a, x = a.b.#c?.()) {}` to `function (a, x = (() => a.b.#c?.())() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unnecessary IIFE\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          callExpression(arrowFunctionExpression([], parentPath.node), []),\n        );\n        return;\n      }\n      parentPath.replaceWith(\n        this.optionalCall(member, parentPath.node.arguments),\n      );\n      return;\n    }\n\n    // delete MEMBER -> _delete(MEMBER)\n    if (this.delete && parentPath.isUnaryExpression({ operator: \"delete\" })) {\n      parentPath.replaceWith(this.delete(member));\n      return;\n    }\n\n    // for (MEMBER of ARR)\n    // for (MEMBER in ARR)\n    // { KEY: MEMBER } = OBJ -> { KEY: _destructureSet(MEMBER) } = OBJ\n    // { KEY: MEMBER = _VALUE } = OBJ -> { KEY: _destructureSet(MEMBER) = _VALUE } = OBJ\n    // {...MEMBER} -> {..._destructureSet(MEMBER)}\n    //\n    // [MEMBER] = ARR -> [_destructureSet(MEMBER)] = ARR\n    // [MEMBER = _VALUE] = ARR -> [_destructureSet(MEMBER) = _VALUE] = ARR\n    // [...MEMBER] -> [..._destructureSet(MEMBER)]\n    if (\n      // for (MEMBER of ARR)\n      // for (MEMBER in ARR)\n      parentPath.isForXStatement({ left: node }) ||\n      // { KEY: MEMBER } = OBJ\n      (parentPath.isObjectProperty({ value: node }) &&\n        parentPath.parentPath.isObjectPattern()) ||\n      // { KEY: MEMBER = _VALUE } = OBJ\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isObjectProperty({ value: parent }) &&\n        parentPath.parentPath.parentPath.isObjectPattern()) ||\n      // [MEMBER] = ARR\n      parentPath.isArrayPattern() ||\n      // [MEMBER = _VALUE] = ARR\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isArrayPattern()) ||\n      // {...MEMBER}\n      // [...MEMBER]\n      parentPath.isRestElement()\n    ) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    if (parentPath.isTaggedTemplateExpression()) {\n      // MEMBER   ->   _get(MEMBER).bind(this)\n      member.replaceWith(this.boundGet(member));\n    } else {\n      // MEMBER   ->   _get(MEMBER)\n      member.replaceWith(this.get(member));\n    }\n  },\n};\n\nexport interface Handler<State> {\n  memoise?(\n    this: HandlerState<State> & State,\n    member: Member,\n    count: number,\n  ): void;\n  destructureSet(\n    this: HandlerState<State> & State,\n    member: Member,\n  ): t.Expression;\n  boundGet(this: HandlerState<State> & State, member: Member): t.Expression;\n  simpleSet?(this: HandlerState<State> & State, member: Member): t.Expression;\n  get(this: HandlerState<State> & State, member: Member): t.Expression;\n  set(\n    this: HandlerState<State> & State,\n    member: Member,\n    value: t.Expression,\n  ): t.Expression;\n  call(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.CallExpression[\"arguments\"],\n  ): t.Expression;\n  optionalCall(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.OptionalCallExpression[\"arguments\"],\n  ): t.Expression;\n  // TODO(Babel 8): Consider making this required, since `.get` doesn't\n  // really work as a fallback for `.delete`\n  delete?(this: HandlerState<State> & State, member: Member): t.Expression;\n}\n\nexport interface HandlerState<State = {}> extends Handler<State> {\n  handle(\n    this: HandlerState<State> & State,\n    member: Member,\n    noDocumentAll?: boolean,\n  ): void;\n  memoiser: AssignmentMemoiser;\n}\n\n// We do not provide a default traversal visitor\n// Instead, caller passes one, and must call `state.handle` on the members\n// it wishes to be transformed.\n// Additionally, the caller must pass in a state object with at least\n// get, set, and call methods.\n// Optionally, a memoise method may be defined on the state, which will be\n// called when the member is a self-referential update.\nexport default function memberExpressionToFunctions<CustomState = {}>(\n  path: NodePath,\n  visitor: Visitor<HandlerState<CustomState>>,\n  state: Handler<CustomState> & CustomState,\n) {\n  path.traverse(visitor, {\n    ...handle,\n    ...state,\n    memoiser: new AssignmentMemoiser(),\n  });\n}\n"],"names":["willPathCastToBoolean","path","maybeWrapped","node","parentPath","isLogicalExpression","operator","right","isSequenceExpression","expressions","length","isConditional","test","isUnaryExpression","isLoop","LOGICAL_OPERATORS","arrowFunctionExpression","assignmentExpression","binaryExpression","booleanLiteral","callExpression","cloneNode","conditionalExpression","identifier","isMemberExpression","isOptionalCallExpression","isOptionalMemberExpression","isUpdateExpression","logicalExpression","memberExpression","nullLiteral","optionalCallExpression","optionalMemberExpression","sequenceExpression","updateExpression","_t","AssignmentMemoiser","constructor","_map","WeakMap","has","key","get","record","value","count","set","toNonOptional","base","property","computed","callee","optional","object","context","scope","maybeGenerateMemoised","replaceWith","arguments","isInDetachedTree","isProgram","container","listKey","parentNode","handle","memoise","member","noDocumentAll","parent","endPath","find","isPattern","willEndPathCastToBoolean","rootParentPath","argument","isAssignmentExpression","left","buildCodeFrameError","isDeleteOperation","isPrivateName","startingOptional","Error","type","startingNode","baseNeedsMemoised","baseRef","parentIsOptionalCall","isOptionalCall","parentIsCall","isCallExpression","optionalCall","call","boundGet","delete","regular","current","endParentPath","replacementPath","baseMemoised","nonNullishCheck","buildUndefinedNode","nullishCheck","endParent","simpleSet","prefix","ref","generateUidIdentifierBasedOnNode","push","id","seq","ref2","operatorTrunc","slice","includes","isForXStatement","isObjectProperty","isObjectPattern","isAssignmentPattern","isArrayPattern","isRestElement","destructureSet","isTaggedTemplateExpression","memberExpressionToFunctions","visitor","state","traverse","memoiser"],"mappings":"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"}
=======
{"version":3,"file":"index.js","sources":["../src/util.ts","../src/index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\n\n/**\n * Test if a NodePath will be cast to boolean when evaluated.\n *\n * @example\n * // returns true\n * const nodePathAQDotB = NodePath(\"if (a?.#b) {}\").get(\"test\"); // a?.#b\n * willPathCastToBoolean(nodePathAQDotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a?.#b\"))\n * @todo Respect transparent expression wrappers\n * @see {@link packages/babel-plugin-proposal-optional-chaining/src/util.js}\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = path;\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n","import type { NodePath, Visitor } from \"@babel/traverse\";\nimport {\n  LOGICAL_OPERATORS,\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  identifier,\n  isMemberExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isUpdateExpression,\n  logicalExpression,\n  memberExpression,\n  nullLiteral,\n  optionalCallExpression,\n  optionalMemberExpression,\n  sequenceExpression,\n  updateExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { willPathCastToBoolean } from \"./util\";\n\nclass AssignmentMemoiser {\n  private _map: WeakMap<t.Expression, { count: number; value: t.Identifier }>;\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key: t.Expression) {\n    return this._map.has(key);\n  }\n\n  get(key: t.Expression) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n    const { value } = record;\n\n    record.count--;\n    if (record.count === 0) {\n      // The `count` access is the outermost function call (hopefully), so it\n      // does the assignment.\n      return assignmentExpression(\"=\", value, key);\n    }\n    return value;\n  }\n\n  set(key: t.Expression, value: t.Identifier, count: number) {\n    return this._map.set(key, { count, value });\n  }\n}\n\nfunction toNonOptional(\n  path: NodePath<t.Expression>,\n  base: t.Expression,\n): t.Expression {\n  const { node } = path;\n  if (isOptionalMemberExpression(node)) {\n    return memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      // object must be a conditional expression because the optional private access in object has been transformed\n      const object = callee.node.object as t.ConditionalExpression;\n      const context = path.scope.maybeGenerateMemoised(object);\n      callee\n        .get(\"object\")\n        .replaceWith(assignmentExpression(\"=\", context, object));\n\n      return callExpression(memberExpression(base, identifier(\"call\")), [\n        context,\n        ...path.node.arguments,\n      ]);\n    }\n\n    return callExpression(base, path.node.arguments);\n  }\n\n  return path.node;\n}\n\n// Determines if the current path is in a detached tree. This can happen when\n// we are iterating on a path, and replace an ancestor with a new node. Babel\n// doesn't always stop traversing the old node tree, and that can cause\n// inconsistencies.\nfunction isInDetachedTree(path: NodePath) {\n  while (path) {\n    if (path.isProgram()) break;\n\n    const { parentPath, container, listKey } = path;\n    const parentNode = parentPath.node;\n    if (listKey) {\n      if (\n        container !==\n        // @ts-expect-error listKey must be a valid parent node key\n        parentNode[listKey]\n      ) {\n        return true;\n      }\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\ntype Member = NodePath<t.OptionalMemberExpression | t.MemberExpression>;\n\nconst handle = {\n  memoise() {\n    // noop.\n  },\n\n  handle(this: HandlerState, member: Member, noDocumentAll: boolean) {\n    const { node, parent, parentPath, scope } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      // Transforming optional chaining requires we replace ancestors.\n      if (isInDetachedTree(member)) return;\n\n      // We're looking for the end of _this_ optional chain, which is actually\n      // the \"rightmost\" property access of the chain. This is because\n      // everything up to that property access is \"optional\".\n      //\n      // Let's take the case of `FOO?.BAR.baz?.qux`, with `FOO?.BAR` being our\n      // member. The \"end\" to most users would be `qux` property access.\n      // Everything up to it could be skipped if it `FOO` were nullish. But\n      // actually, we can consider the `baz` access to be the end. So we're\n      // looking for the nearest optional chain that is `optional: true`.\n      const endPath = member.find(({ node, parent }) => {\n        if (isOptionalMemberExpression(parent)) {\n          // We need to check `parent.object` since we could be inside the\n          // computed expression of a `bad?.[FOO?.BAR]`. In this case, the\n          // endPath is the `FOO?.BAR` member itself.\n          return parent.optional || parent.object !== node;\n        }\n        if (isOptionalCallExpression(parent)) {\n          // Checking `parent.callee` since we could be in the arguments, eg\n          // `bad?.(FOO?.BAR)`.\n          // Also skip `FOO?.BAR` in `FOO?.BAR?.()` since we need to transform the optional call to ensure proper this\n          return (\n            // In FOO?.#BAR?.(), endPath points the optional call expression so we skip FOO?.#BAR\n            (node !== member.node && parent.optional) || parent.callee !== node\n          );\n        }\n        return true;\n      }) as NodePath<t.OptionalMemberExpression>;\n\n      // Replace `function (a, x = a.b?.#c) {}` to `function (a, x = (() => a.b?.#c)() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unecessary IIFE\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          callExpression(arrowFunctionExpression([], endPath.node), []),\n        );\n        return;\n      }\n\n      const willEndPathCastToBoolean = willPathCastToBoolean(endPath);\n\n      const rootParentPath = endPath.parentPath;\n      if (\n        rootParentPath.isUpdateExpression({ argument: node }) ||\n        rootParentPath.isAssignmentExpression({ left: node })\n      ) {\n        throw member.buildCodeFrameError(`can't handle assignment`);\n      }\n      const isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\",\n      });\n      if (\n        isDeleteOperation &&\n        endPath.isOptionalMemberExpression() &&\n        endPath.get(\"property\").isPrivateName()\n      ) {\n        // @babel/parser will throw error on `delete obj?.#x`.\n        // This error serves as fallback when `delete obj?.#x` is constructed from babel types\n        throw member.buildCodeFrameError(\n          `can't delete a private class element`,\n        );\n      }\n\n      // Now, we're looking for the start of this optional chain, which is\n      // optional to the left of this member.\n      //\n      // Let's take the case of `foo?.bar?.baz.QUX?.BAM`, with `QUX?.BAM` being\n      // our member. The \"start\" to most users would be `foo` object access.\n      // But actually, we can consider the `bar` access to be the start. So\n      // we're looking for the nearest optional chain that is `optional: true`,\n      // which is guaranteed to be somewhere in the object/callee tree.\n      let startingOptional: NodePath<t.Expression> = member;\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n        // prevent infinite loop: unreachable if the AST is well-formed\n        throw new Error(\n          `Internal error: unexpected ${startingOptional.node.type}`,\n        );\n      }\n\n      // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n      const startingNode = startingOptional.isOptionalMemberExpression()\n        ? // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n          startingOptional.node.object\n        : // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n          startingOptional.node.callee;\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised ?? startingNode;\n\n      // Compute parentIsOptionalCall before `startingOptional` is replaced\n      // as `node` may refer to `startingOptional.node` before replaced.\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node,\n      });\n      // here we use a function to wrap `parentIsOptionalCall` to get type\n      // for parent, do not use it anywhere else\n      // See https://github.com/microsoft/TypeScript/issues/10421\n      const isOptionalCall = (\n        parent: t.Node,\n      ): parent is t.OptionalCallExpression => parentIsOptionalCall;\n      // if parentIsCall is true, it implies that node.extra.parenthesized is always true\n      const parentIsCall = parentPath.isCallExpression({ callee: node });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n      if (isOptionalCall(parent)) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        // `(a?.#b)()` to `(a == null ? void 0 : a.#b.bind(a))()`\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular: t.Expression = member.node;\n      for (let current: NodePath = member; current !== endPath; ) {\n        const parentPath = current.parentPath as NodePath<t.Expression>;\n        // skip transforming `Foo.#BAR?.call(FOO)`\n        if (\n          parentPath === endPath &&\n          isOptionalCall(parent) &&\n          parent.optional\n        ) {\n          regular = parentPath.node;\n          break;\n        }\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context: t.Identifier;\n      const endParentPath = endPath.parentPath as NodePath<t.Expression>;\n      if (\n        isMemberExpression(regular) &&\n        endParentPath.isOptionalCallExpression({\n          callee: endPath.node,\n          optional: true,\n        })\n      ) {\n        const { object } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n        if (context) {\n          regular.object = assignmentExpression(\n            \"=\",\n            context,\n            // object must not be Super when `context` is an identifier\n            object as t.Expression,\n          );\n        }\n      }\n\n      let replacementPath: NodePath = endPath;\n      if (isDeleteOperation) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      const baseMemoised = baseNeedsMemoised\n        ? assignmentExpression(\n            \"=\",\n            // When base needs memoised, the baseRef must be an identifier\n            cloneNode(baseRef as t.Identifier),\n            cloneNode(startingNode),\n          )\n        : cloneNode(baseRef);\n\n      if (willEndPathCastToBoolean) {\n        let nonNullishCheck;\n        if (noDocumentAll) {\n          nonNullishCheck = binaryExpression(\"!=\", baseMemoised, nullLiteral());\n        } else {\n          nonNullishCheck = logicalExpression(\n            \"&&\",\n            binaryExpression(\"!==\", baseMemoised, nullLiteral()),\n            binaryExpression(\n              \"!==\",\n              cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n        replacementPath.replaceWith(\n          logicalExpression(\"&&\", nonNullishCheck, regular),\n        );\n      } else {\n        let nullishCheck;\n        if (noDocumentAll) {\n          nullishCheck = binaryExpression(\"==\", baseMemoised, nullLiteral());\n        } else {\n          nullishCheck = logicalExpression(\n            \"||\",\n            binaryExpression(\"===\", baseMemoised, nullLiteral()),\n            binaryExpression(\n              \"===\",\n              cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n\n        replacementPath.replaceWith(\n          conditionalExpression(\n            nullishCheck,\n            isDeleteOperation\n              ? booleanLiteral(true)\n              : scope.buildUndefinedNode(),\n            regular,\n          ),\n        );\n      }\n\n      // context and isDeleteOperation can not be both truthy\n      if (context) {\n        const endParent = endParentPath.node as t.OptionalCallExpression;\n        endParentPath.replaceWith(\n          optionalCallExpression(\n            optionalMemberExpression(\n              endParent.callee,\n              identifier(\"call\"),\n              false,\n              true,\n            ),\n            [cloneNode(context), ...endParent.arguments],\n            false,\n          ),\n        );\n      }\n\n      return;\n    }\n\n    // MEMBER++   ->   _set(MEMBER, (ref = _get(MEMBER), ref2 = ref++, ref)), ref2\n    // ++MEMBER   ->   _set(MEMBER, (ref = _get(MEMBER), ++ref))\n    if (isUpdateExpression(parent, { argument: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, prefix } = parent;\n\n      // Give the state handler a chance to memoise the member, since we'll\n      // reference it twice. The second access (the set) should do the memo\n      // assignment.\n      this.memoise(member, 2);\n\n      const ref = scope.generateUidIdentifierBasedOnNode(node);\n      scope.push({ id: ref });\n\n      const seq: t.Expression[] = [\n        // ref = _get(MEMBER)\n        assignmentExpression(\"=\", cloneNode(ref), this.get(member)),\n      ];\n\n      if (prefix) {\n        seq.push(updateExpression(operator, cloneNode(ref), prefix));\n\n        // (ref = _get(MEMBER), ++ref)\n        const value = sequenceExpression(seq);\n        parentPath.replaceWith(this.set(member, value));\n\n        return;\n      } else {\n        const ref2 = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({ id: ref2 });\n\n        seq.push(\n          assignmentExpression(\n            \"=\",\n            cloneNode(ref2),\n            updateExpression(operator, cloneNode(ref), prefix),\n          ),\n          cloneNode(ref),\n        );\n\n        // (ref = _get(MEMBER), ref2 = ref++, ref)\n        const value = sequenceExpression(seq);\n        parentPath.replaceWith(\n          sequenceExpression([this.set(member, value), cloneNode(ref2)]),\n        );\n\n        return;\n      }\n    }\n\n    // MEMBER = VALUE   ->   _set(MEMBER, VALUE)\n    // MEMBER += VALUE   ->   _set(MEMBER, _get(MEMBER) + VALUE)\n    // MEMBER ??= VALUE   ->   _get(MEMBER) ?? _set(MEMBER, VALUE)\n    if (parentPath.isAssignmentExpression({ left: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, right: value } = parentPath.node;\n\n      if (operator === \"=\") {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const operatorTrunc = operator.slice(0, -1);\n        if (LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          // Give the state handler a chance to memoise the member, since we'll\n          // reference it twice. The first access (the get) should do the memo\n          // assignment.\n          this.memoise(member, 1);\n          parentPath.replaceWith(\n            logicalExpression(\n              operatorTrunc as t.LogicalExpression[\"operator\"],\n              this.get(member),\n              this.set(member, value),\n            ),\n          );\n        } else {\n          // Here, the second access (the set) is evaluated first.\n          this.memoise(member, 2);\n          parentPath.replaceWith(\n            this.set(\n              member,\n              binaryExpression(\n                operatorTrunc as t.BinaryExpression[\"operator\"],\n                this.get(member),\n                value,\n              ),\n            ),\n          );\n        }\n      }\n      return;\n    }\n\n    // MEMBER(ARGS) -> _call(MEMBER, ARGS)\n    if (parentPath.isCallExpression({ callee: node })) {\n      parentPath.replaceWith(this.call(member, parentPath.node.arguments));\n      return;\n    }\n\n    // MEMBER?.(ARGS) -> _optionalCall(MEMBER, ARGS)\n    if (parentPath.isOptionalCallExpression({ callee: node })) {\n      // Replace `function (a, x = a.b.#c?.()) {}` to `function (a, x = (() => a.b.#c?.())() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unecessary IIFE\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          callExpression(arrowFunctionExpression([], parentPath.node), []),\n        );\n        return;\n      }\n      parentPath.replaceWith(\n        this.optionalCall(member, parentPath.node.arguments),\n      );\n      return;\n    }\n\n    // for (MEMBER of ARR)\n    // for (MEMBER in ARR)\n    // { KEY: MEMBER } = OBJ -> { KEY: _destructureSet(MEMBER) } = OBJ\n    // { KEY: MEMBER = _VALUE } = OBJ -> { KEY: _destructureSet(MEMBER) = _VALUE } = OBJ\n    // {...MEMBER} -> {..._destructureSet(MEMBER)}\n    //\n    // [MEMBER] = ARR -> [_destructureSet(MEMBER)] = ARR\n    // [MEMBER = _VALUE] = ARR -> [_destructureSet(MEMBER) = _VALUE] = ARR\n    // [...MEMBER] -> [..._destructureSet(MEMBER)]\n    if (\n      // for (MEMBER of ARR)\n      // for (MEMBER in ARR)\n      parentPath.isForXStatement({ left: node }) ||\n      // { KEY: MEMBER } = OBJ\n      (parentPath.isObjectProperty({ value: node }) &&\n        parentPath.parentPath.isObjectPattern()) ||\n      // { KEY: MEMBER = _VALUE } = OBJ\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isObjectProperty({ value: parent }) &&\n        parentPath.parentPath.parentPath.isObjectPattern()) ||\n      // [MEMBER] = ARR\n      parentPath.isArrayPattern() ||\n      // [MEMBER = _VALUE] = ARR\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isArrayPattern()) ||\n      // {...MEMBER}\n      // [...MEMBER]\n      parentPath.isRestElement()\n    ) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    if (parentPath.isTaggedTemplateExpression()) {\n      // MEMBER   ->   _get(MEMBER).bind(this)\n      member.replaceWith(this.boundGet(member));\n    } else {\n      // MEMBER   ->   _get(MEMBER)\n      member.replaceWith(this.get(member));\n    }\n  },\n};\n\nexport interface Handler<State> {\n  memoise?(\n    this: HandlerState<State> & State,\n    member: Member,\n    count: number,\n  ): void;\n  destructureSet(\n    this: HandlerState<State> & State,\n    member: Member,\n  ): t.Expression;\n  boundGet(this: HandlerState<State> & State, member: Member): t.Expression;\n  simpleSet?(this: HandlerState<State> & State, member: Member): t.Expression;\n  get(this: HandlerState<State> & State, member: Member): t.Expression;\n  set(\n    this: HandlerState<State> & State,\n    member: Member,\n    value: t.Expression,\n  ): t.Expression;\n  call(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.CallExpression[\"arguments\"],\n  ): t.Expression;\n  optionalCall(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.OptionalCallExpression[\"arguments\"],\n  ): t.Expression;\n}\n\nexport interface HandlerState<State = {}> extends Handler<State> {\n  handle(\n    this: HandlerState<State> & State,\n    member: Member,\n    noDocumentAll?: boolean,\n  ): void;\n  memoiser: AssignmentMemoiser;\n}\n\n// We do not provide a default traversal visitor\n// Instead, caller passes one, and must call `state.handle` on the members\n// it wishes to be transformed.\n// Additionally, the caller must pass in a state object with at least\n// get, set, and call methods.\n// Optionally, a memoise method may be defined on the state, which will be\n// called when the member is a self-referential update.\nexport default function memberExpressionToFunctions<CustomState = {}>(\n  path: NodePath,\n  visitor: Visitor<HandlerState<CustomState>>,\n  state: Handler<CustomState> & CustomState,\n) {\n  path.traverse(visitor, {\n    ...handle,\n    ...state,\n    memoiser: new AssignmentMemoiser(),\n  });\n}\n"],"names":["willPathCastToBoolean","path","maybeWrapped","node","parentPath","isLogicalExpression","operator","right","isSequenceExpression","expressions","length","isConditional","test","isUnaryExpression","isLoop","LOGICAL_OPERATORS","arrowFunctionExpression","assignmentExpression","binaryExpression","booleanLiteral","callExpression","cloneNode","conditionalExpression","identifier","isMemberExpression","isOptionalCallExpression","isOptionalMemberExpression","isUpdateExpression","logicalExpression","memberExpression","nullLiteral","optionalCallExpression","optionalMemberExpression","sequenceExpression","updateExpression","AssignmentMemoiser","constructor","_map","WeakMap","has","key","get","record","value","count","set","toNonOptional","base","property","computed","callee","optional","object","context","scope","maybeGenerateMemoised","replaceWith","arguments","isInDetachedTree","isProgram","container","listKey","parentNode","handle","memoise","member","noDocumentAll","parent","endPath","find","isPattern","willEndPathCastToBoolean","rootParentPath","argument","isAssignmentExpression","left","buildCodeFrameError","isDeleteOperation","isPrivateName","startingOptional","Error","type","startingNode","baseNeedsMemoised","baseRef","parentIsOptionalCall","isOptionalCall","parentIsCall","isCallExpression","optionalCall","call","boundGet","regular","current","endParentPath","replacementPath","baseMemoised","nonNullishCheck","buildUndefinedNode","nullishCheck","endParent","simpleSet","prefix","ref","generateUidIdentifierBasedOnNode","push","id","seq","ref2","operatorTrunc","slice","includes","isForXStatement","isObjectProperty","isObjectPattern","isAssignmentPattern","isArrayPattern","isRestElement","destructureSet","isTaggedTemplateExpression","memberExpressionToFunctions","visitor","state","traverse","memoiser"],"mappings":"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"}
>>>>>>> aa9555174f0cb4a525242493edcdb44bcc81bab9
